{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "1e0065c1_8a2e2c3e",
        "filename": "src/actions.c",
        "patchSetId": 1
      },
      "lineNbr": 154,
      "author": {
        "id": 1019142
      },
      "writtenOn": "2021-10-25T12:49:53Z",
      "side": 1,
      "message": "question: why is this broken now ? Did the change from statx to rbh_statx changed the size of this field and stx_size ?",
      "range": {
        "startLine": 154,
        "startChar": 47,
        "endLine": 154,
        "endChar": 64
      },
      "revId": "a73a9f9811511e854d924ecaf2ced500705cc8a4",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "99d3e6be_ff90cc3d",
        "filename": "src/actions.c",
        "patchSetId": 1
      },
      "lineNbr": 154,
      "author": {
        "id": 1019048
      },
      "writtenOn": "2021-10-25T12:51:31Z",
      "side": 1,
      "message": "On my end, I got this error. Why did I get it though is a mystery.\n\n\n[1/7] Compiling C object \u0027rbh-find@exe/src_actions.c.o\u0027.\nFAILED: rbh-find@exe/src_actions.c.o \ncc -Irbh-find@exe -I. -I.. -I../ -I../include -fdiagnostics-color\u003dalways -pipe -D_FILE_OFFSET_BITS\u003d64 -Wall -Winvalid-pch -Wextra -Wpedantic -Werror -g -Wno-pedantic -D_GNU_SOURCE -DHAVE_CONFIG_H  -MD -MQ \u0027rbh-find@exe/src_actions.c.o\u0027 -MF \u0027rbh-find@exe/src_actions.c.o.d\u0027 -o \u0027rbh-find@exe/src_actions.c.o\u0027 -c ../src/actions.c\n../src/actions.c: In function ‚Äòstatx_print_ls_dils‚Äô:\n../src/actions.c:154:33: error: format ‚Äò%lld‚Äô expects argument of type ‚Äòlong long int‚Äô, but argument 4 has type ‚Äòuint64_t‚Äô {aka ‚Äòconst long unsigned int‚Äô} [-Werror\u003dformat\u003d]\n         rc \u003d fprintf(file, \"%*lld\", length.ino, statxbuf-\u003estx_ino);\n                             ~~~~^               ~~~~~~~~~~~~~~~~~\n                             %*ld\n../src/actions.c:215:34: error: format ‚Äò%lld‚Äô expects argument of type ‚Äòlong long int‚Äô, but argument 4 has type ‚Äòuint64_t‚Äô {aka ‚Äòconst long unsigned int‚Äô} [-Werror\u003dformat\u003d]\n         rc \u003d fprintf(file, \" %*lld\", length.size, statxbuf-\u003estx_size) - 1;\n                              ~~~~^                ~~~~~~~~~~~~~~~~~~\n                              %*ld\ncc1: all warnings being treated as errors",
      "parentUuid": "1e0065c1_8a2e2c3e",
      "range": {
        "startLine": 154,
        "startChar": 47,
        "endLine": 154,
        "endChar": 64
      },
      "revId": "a73a9f9811511e854d924ecaf2ced500705cc8a4",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8e352154_534f64c5",
        "filename": "src/actions.c",
        "patchSetId": 1
      },
      "lineNbr": 154,
      "author": {
        "id": 1003556
      },
      "writtenOn": "2021-10-25T13:41:33Z",
      "side": 1,
      "message": "u64 being a long or a long long is one of the annoying things about C... on x86 (32bit), long is 32bits but on x86_64 long is 64bits, but on both of these long long is 64bit.\nI\u0027m too lazy to look it up but the C standard only says that long int must stores \"at least x\" so it can change depending on the arch like this\n\nAnyway, the linux kernel decided u64 is a long long on every arch so stx_ino which is defined as __u64 in the linux/stat.h is a long long (see asm-generic/types.h: int-ll64 is used everywhere now. -- and asm-generic/int-ll64.h which defines __u64 as long long) -- these are all kernel headers.\n\nBut uint64 used for rbh_statx is defined as unsigned long in bits/types.h...\n(note statx is -also- defined in glibc headers (bits/types/struct_statx.h) with __uint64_t, and that one is also a long - so glibc and the kernel just don\u0027t agree on this point...)\n\n\nAnyway I\u0027d be tempted to say that since we\u0027ve always used the kernel version of the struct rbh_statx should keep these fields as long long, but since there are/will be checks I\u0027m happy with either version here. If you use %ld though that won\u0027t work on 32 bit systems so you should use PRIu64 or similar.",
      "parentUuid": "99d3e6be_ff90cc3d",
      "range": {
        "startLine": 154,
        "startChar": 47,
        "endLine": 154,
        "endChar": 64
      },
      "revId": "a73a9f9811511e854d924ecaf2ced500705cc8a4",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e71720a9_ac45f30c",
        "filename": "src/actions.c",
        "patchSetId": 1
      },
      "lineNbr": 154,
      "author": {
        "id": 1018755
      },
      "writtenOn": "2021-10-25T20:23:22Z",
      "side": 1,
      "message": "\u003e I\u0027d be tempted to say that since we\u0027ve always used the kernel version of the struct rbh_statx should keep these fields as long long\n\nI don\u0027t know what the kernel developer\u0027s reasoning is, but the C standard clearly defines exact-width integers:\n\n\u003e 7.20.1.1 Exact-width integer types\n\u003e\n\u003e The typedef name intN_t designates a signed integer type with width N, no padding bits, and a two‚Äôs complement representation. Thus, int8_t denotes such a signed integer type with a width of exactly 8 bits.\n\u003e The typedef name uintN_t designates an unsigned integer type with width N and no padding bits. Thus, uint24_t denotes such an unsigned integer type with a width of exactly 24 bits.\n\u003e These types are optional. However, if an implementation provides integer types with widths of 8, 16, 32, or 64 bits, no padding bits, and (for the signed types) that have a two‚Äôs complement representation, it shall define the corresponding typedef names.\n\nWell, IIUC it defines them as optional, unless the implementation already provides the same types under different names... So, except for uint16_t, they\u0027re not so optional, are they? üòê\n\nI\u0027m tempted to say: to hell with that. We need a 64-bit unsigned integer, uint64_t is clearly the right type. Let\u0027s leave it to clang/gcc, glibc and the kernel developers to figure a long term solution to this inconsistency.\n\n\u003e If you use %ld though that won\u0027t work on 32 bit systems so you should use PRIu64 or similar.\n\nAgreed.",
      "parentUuid": "8e352154_534f64c5",
      "range": {
        "startLine": 154,
        "startChar": 47,
        "endLine": 154,
        "endChar": 64
      },
      "revId": "a73a9f9811511e854d924ecaf2ced500705cc8a4",
      "serverId": "d5d70762-12d0-45a1-890d-524b12d3f735"
    }
  ]
}